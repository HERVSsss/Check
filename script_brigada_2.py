# -*- coding: utf-8 -*-
"""Script_brigada_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AAuGhSs1CwLPfO5_kaqoXDuTiUjiqvxv
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Скрипт самостоятельной работы 2-й бригады
по дисциплине "Статистический анализ в Python"

Этот модуль выполняет визуализацию данных, а также подсчет статистик,
необходимых для предварительного анализа исходных данных.
Данные должны находиться в одной папке с этим скриптом в файле "data.csv".

Авторы:
    Потемкин В.А.
    Коште А.Э.
    Джинчарадзе Л.Т.
"""

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import pandas as pd
import numpy as np
import scipy.stats as stats


df = pd.read_csv('data_1.csv', sep=';')

# # Основные статистики


des = df.drop(['year', 'num_of_owners'], axis=1).describe().T
kurt = []
skew = []
median = []
iqr = []
missing = []
for ind in des.index:
    kurt.append(stats.kurtosis(df[ind]))
    skew.append(stats.skew(df[ind]))
    median.append(np.median(df[ind]))
    iqr.append(stats.iqr(df[ind]))
    missing.append(df[ind].isna().sum())
des['iqr'] = iqr
des['median'] = median
des['skew'] = skew
des['kurtosis'] = kurt
des['missing'] = missing

new_index = ['count', 'missing', 'median', 'mean', 'std', 'min',
             'max', '25%', '50%', '75%', 'iqr', 'skew', 'kurtosis']
des = des.T.reindex(new_index)
des.to_excel('stats.xlsx')
print(des)

# # Анализ количественных переменных


def sturges_bins(data):
    """
    Вычисляет количество столбиков для построения гистограммы по правилу Стерджесса

    Parameters
    ----------
    data : array-like
           Массив данных, для которого необходимо построить гистограмму

    Returns
    -------
    n_bins : integer
             Количество столбиков для построения гистограммы
    """
    n_bins = len(data)
    return 1 + int(np.ceil(np.log2(n_bins)))


def freedman_diaconis_bins(data):
    """
    Вычисляет количество столбиков для построения гистограммы по правилу Фридмана-Диакониса

    Parameters
    ----------
    data : array-like
           Массив данных, для которого необходимо построить гистограмму

    Returns
    -------
    n_bins : integer
             Количество столбиков для построения гистограммы
    """
    n_bins = len(data)
    h_height = 2 * stats.iqr(data) / n_bins**(1 / 3)
    return int(np.ceil((data.max() - data.min()) / h_height))


def scott_bins(data):
    """
    Вычисляет количество столбиков для построения гистограммы по правилу Скотта

    Parameters
    ----------
    data : array-like
           Массив данных, для которого необходимо построить гистограмму

    Returns
    -------
    n_bins : integer
             Количество столбиков для построения гистограммы
    """
    n_bins = len(data)
    h_height = 3.5 * data.std() / n_bins**(1 / 3)
    return int(np.ceil((data.max() - data.min()) / h_height))

# ### Гистограмма распределения цен, формула Скотта


plt.figure(figsize=(10, 8))
ax = plt.subplot()

ax.hist(df['price'], bins=scott_bins(df['price']),
        color='tab:cyan', edgecolor='black', density=True)
ax.patch.set_facecolor('whitesmoke')

ax.set_xlabel('Цена, млн руб.', fontsize=14)
ax.set_ylabel('Относительная частота', fontsize=14)
ax.set_title('Гистограмма распределения цен', fontsize=14)

x = np.linspace(-0.2e6, df['price'].max(), 200)
y = stats.norm.pdf(x, loc=df['price'].mean(), scale=df['price'].std())
ax.plot(x, y, color='black')


mu_3_sigma = df['price'].mean() + 3 * df['price'].std()

xt = ax.get_xticks()
xt = np.append(xt, mu_3_sigma)
ax.set_xticks(xt)

ax.text(3.25e6, 1.8e-7, '$\\mu+3\\sigma$', fontsize=13)
ax.annotate("", xy=(mu_3_sigma, 0.4e-7), xytext=(mu_3_sigma, 1.7e-7),
            arrowprops=dict(arrowstyle='->', color='crimson'))

ax.text(4.1e6, 1.8e-7, 'Выбросы', fontsize=13)
ax.annotate("", xy=(3.65e6, 0.4e-7), xytext=(4.2e6, 1.6e-7),
            arrowprops=dict(arrowstyle='->'))
ax.annotate("", xy=(4.2e6, 0.4e-7), xytext=(4.4e6, 1.6e-7),
            arrowprops=dict(arrowstyle='->'))
ax.annotate("", xy=(4.8e6, 0.4e-7), xytext=(4.6e6, 1.6e-7),
            arrowprops=dict(arrowstyle='->'))

props = dict(boxstyle='round', facecolor='oldlace', alpha=0.5)
ax.text(4e6, 8.5e-7, f'mean={df["price"].mean():.2e}\n'
        f'std={df["price"].std():.2e}\n'
        f'N={df["price"].count()}', fontsize=12, bbox=props)
ax.text(1e6, 5.2e-7, 'По Скотту', fontsize=14)
ax.xaxis.set_major_formatter(lambda x, p: format(round(x / 10**6, 2), ','))
ax.set_xlim(-0.2e6, 5.2e6)

plt.savefig('Гистограмма распределения цен.png')

# ### Гистограмма распределения мощностей, формула Стерджесса


plt.figure(figsize=(10, 8))
ax = plt.subplot()

ax.hist(df['engine_power'], bins=sturges_bins(df['engine_power']),
        color='tab:cyan', edgecolor='black', density=True)
ax.patch.set_facecolor('whitesmoke')

ax.set_xlabel('Мощность двигателя, л/с', fontsize=14)
ax.set_ylabel('Относительная частота', fontsize=14)
ax.set_title('Гистограмма распределения мощностей двигателей', fontsize=14)

x = np.linspace(40, df['engine_power'].max(), 200)
y = stats.norm.pdf(x, loc=df['engine_power'].mean(),
                   scale=df['engine_power'].std())
ax.plot(x, y, color='black')


mu_3_sigma = df['engine_power'].mean() + 3 * df['engine_power'].std()

ax.text(400, 0.0016, '$\\mu+3\\sigma$', fontsize=13)
ax.annotate("", xy=(mu_3_sigma, 0.0003), xytext=(mu_3_sigma, 0.0015),
            arrowprops=dict(arrowstyle='->', color='crimson'))

ax.text(490, 0.0016, 'Выбросы', fontsize=13)
ax.annotate("", xy=(450, 0.0002), xytext=(
    510, 0.0015), arrowprops=dict(arrowstyle='->'))
ax.annotate("", xy=(530, 0.0002), xytext=(
    520, 0.0015), arrowprops=dict(arrowstyle='->'))
ax.annotate("", xy=(570, 0.0002), xytext=(
    530, 0.0015), arrowprops=dict(arrowstyle='->'))

props = dict(boxstyle='round', facecolor='oldlace', alpha=0.5)
ax.text(510, 0.0056, f'mean={df["engine_power"].mean():.2f}\n'
        f'std={df["engine_power"].std():.2f}\n'
        f'N={df["engine_power"].count()}', fontsize=12, bbox=props)
ax.text(220, 0.005, 'По Стерджессу', fontsize=14)
ax.set_xticks([50 * x for x in range(13)])
ax.set_xlim(40, 630)

plt.savefig('Гистограмма распределения мощностей двигателей.png')

# ### Гистограмма распределения пробега, формула Стерджесса


plt.figure(figsize=(10, 8))
ax = plt.subplot()

ax.hist(df["mileage"], bins=freedman_diaconis_bins(df["mileage"]),
        color='tab:cyan', edgecolor='black', density=True)
ax.patch.set_facecolor('whitesmoke')

ax.set_xlabel('Пробег, тыс. км', fontsize=14)
ax.set_ylabel('Относительная частота', fontsize=14)
ax.set_title('Гистограмма распределения пробега', fontsize=14)

x = np.linspace(-0.2e5, 0.5e6, 200)
y = stats.norm.pdf(x, loc=df["mileage"].mean(), scale=df["mileage"].std())
ax.plot(x, y, color='black')

mu_3_sigma = df['mileage'].mean() + 3 * df['mileage'].std()

ax.text(mu_3_sigma - 0.1 * mu_3_sigma, 1e-6, '$\\mu+3\\sigma$', fontsize=13)
ax.set_xlim(0, 1e6)
ax.annotate("", xy=(mu_3_sigma, 0.2e-6), xytext=(mu_3_sigma, 0.9e-6),
            arrowprops=dict(arrowstyle='->', color='crimson'))

ax.text(5.6e5, 1e-6, 'Выбросы', fontsize=13)
ax.annotate("", xy=(4.7e5, 2e-7), xytext=(5.9e5, 0.9e-6),
            arrowprops=dict(arrowstyle='->'))
ax.annotate("", xy=(5.5e5, 1e-7), xytext=(6.1e5, 0.9e-6),
            arrowprops=dict(arrowstyle='->'))
ax.annotate("", xy=(9.7e5, 1e-7), xytext=(6.3e5, 0.9e-6),
            arrowprops=dict(arrowstyle='->'))

props = dict(boxstyle='round', facecolor='oldlace', alpha=0.5)
ax.text(7.7e5, 5e-6, f'mean={df["mileage"].mean():.2e}\n'
        f'std={df["mileage"].std():.2e}\n'
        f'N={df["mileage"].count()}', fontsize=12, bbox=props)
ax.text(0.2e6, 4.5e-6, 'По Фридману-Диаконису', fontsize=14)
ax.set_xlim(-0.2e5, 1e6)
ax.set_xticks([x * 10**5 for x in range(11)])
ax.xaxis.set_major_formatter(lambda x, p: format(int(x / 1000), ','))

plt.savefig('Гистограмма распределения пробега.png')

# # Анализ качественных переменных

# ### Диаграмма Парето для марок авто


brand = df['brand'].value_counts()

plt.figure(figsize=(10, 8))
ax = plt.subplot()
ax.patch.set_facecolor('whitesmoke')
ax.bar(brand.index, brand.values, edgecolor='black', color='tab:cyan')

rects = ax.patches
for rect, label in zip(rects, brand):
    height = rect.get_height()
    ax.text(rect.get_x() + rect.get_width() / 2, height + 5, label,
            ha='center', va='bottom')

ax.set_title('Диаграмма Парето для марок автомобилей', fontsize=14)
ax.set_xlabel('Марка автомобиля', fontsize=14)
ax.set_ylabel('Частота', fontsize=14)

plt.xticks(fontsize=10, rotation=60)

plt.savefig('Диаграмма Парето для марок авто.png')

# Диаграмма Парето для количества владельцев


owners = df['num_of_owners'].value_counts()

plt.figure(figsize=(10, 8))
ax = plt.subplot()
ax.patch.set_facecolor('whitesmoke')
ax.bar(owners.index, owners.values, edgecolor='black', color='tab:cyan')

rects = ax.patches
for rect, label in zip(rects, owners):
    height = rect.get_height()
    ax.text(rect.get_x() + rect.get_width() / 2, height + 20, label,
            ha='center', va='bottom')

ax.set_title('Диаграмма Парето для количества владельцев', fontsize=14)
ax.set_xlabel('Количество владельцев', fontsize=14)
ax.set_ylabel('Частота', fontsize=14)
ax.set_xticks([1, 2, 3])

plt.savefig('Диаграмма Парето для количества владельцев.png')

# ### Диаграмма Парето для года выпуска


year = df['year'].value_counts()
prices = []
prices.append(len(list(df[df['year'] < 1980]['price'])))
prices.append(
    len(list(df[(df['year'] < 1990) & (df['year'] >= 1980)]['price'])))
prices.append(
    len(list(df[(df['year'] < 2000) & (df['year'] >= 1990)]['price'])))
prices.append(
    len(list(df[(df['year'] < 2010) & (df['year'] >= 2000)]['price'])))
prices.append(len(list(df[df['year'] >= 2010]['price'])))
labels = ['до 1980', '1980-1989', '1990-1999', '2000-2009', '2010-2020']

plt.figure(figsize=(10, 8))
ax = plt.subplot()
ax.patch.set_facecolor('whitesmoke')
ax.bar(labels, prices, edgecolor='black', color='tab:cyan')

rects = ax.patches
for rect, label in zip(rects, prices):
    height = rect.get_height()
    ax.text(rect.get_x() + rect.get_width() / 2, height + 5, label,
            ha='center', va='bottom')

ax.set_title('Диаграмма Парето для года выпуска', fontsize=14)
ax.set_xlabel('Год выпуска', fontsize=14)
ax.set_ylabel('Частота', fontsize=14)

plt.xticks(fontsize=12)

plt.savefig('Диаграмма Парето для года выпуска.png')

# # Анализ статистической связи

# ### Графический анализ пары «числовая зависимая переменная – числовая независимая переменная».


variables = {'engine_power': 'Мощность двигателя, л/с',
             'mileage': 'Пробег, тыс. км'}
brands = sorted(list(set(df['brand'])))
colors = ['indigo', 'mediumpurple', 'deeppink', 'grey',
          'fuchsia', 'gold', 'darkviolet', 'dodgerblue',
          'paleturquoise', 'salmon', 'darkmagenta', 'greenyellow', 'tab:cyan']

#colors = ['crimson', 'slateblue', 'teal', 'olive',
          #'darkorange', 'hotpink', 'darkviolet', 'dodgerblue',
          #'lime', 'dimgray', 'darkgoldenrod', 'yellow', 'chocolate']

cmap = {}
for b, c in zip(brands, colors):
    cmap[b] = c

fig, ax = plt.subplots(1, len(variables), figsize=(len(variables) * 12, 10))
for i, name in enumerate(variables):
    ax[i].scatter(
        df[name],
        df['price'],
        alpha=1,
        marker='.',
        c=df['brand'].map(cmap),
        label=list(
            cmap.keys()),
        s=200)
    ax[i].grid()
    ax[i].patch.set_facecolor('whitesmoke')
    ax[i].set_xlabel(variables[name], fontsize=14)
    ax[i].set_ylabel('Цена, млн руб.', fontsize=14)
    ax[i].yaxis.set_major_formatter(
        lambda x, p: format(round(x / 10**6, 2), ','))
    handles = []
    for key, val in cmap.items():
        handles.append(mpatches.Patch(color=val, label=key))
    ax[i].legend(handles=handles, fontsize=10)

ax[0].set_title('Зависимость цены авто от мощности двигателя', fontsize=14)
ax[1].set_title('Зависимость цены авто от пробега', fontsize=14)

ax[1].set_xticks([x * 10**5 for x in range(11)])
ax[1].xaxis.set_major_formatter(lambda x, p: format(int(x / 1000), ','))


X = list(df['engine_power'])
Y = list(df['price'])
mean_x = np.mean(X)
mean_y = np.mean(Y)
NUMER = 0
DENOM = 0
for i, elem in enumerate(X):
    NUMER += (elem - mean_x) * (Y[i] - mean_y)
    DENOM += (elem - mean_x) ** 2

m = NUMER / DENOM
c = mean_y - (m * mean_x)
MAX = 605
MIN = 25
x = np.linspace(MIN, MAX, 200)
y = c + m * x
ax[0].plot(x, y, '-k', linewidth=2.5)
props = dict(boxstyle='round', facecolor='oldlace', alpha=1)
ax[0].text(526, 2.62e6, f'y={m:.1f}x+{c:.1f}', fontsize=8.5, bbox=props)
ax[0].set_xlim(20, 610)


plt.subplots_adjust(wspace=0.1)
plt.savefig('Зависимость цены авто от мощности, пробега.png')


lst = ['engine_power', 'mileage']
for name in lst:
    coef, p = stats.spearmanr(df['price'], df[name])
    coef1, p1 = stats.kendalltau(df['price'], df[name])
    print(f'Spearmans correlation coeff for price-{name} : {coef:.3f}')
    print(f'Kendall correlation coeff for price-{name} : {coef1:.3f}')

# ### Графический анализ пары «числовая зависимая переменная – качественная независимая переменная».

# #### Зависимость цены авто от марки


prices = []
for b in brand.index:
    prices.append(df[df['brand'] == b]['price'])
fig, ax = plt.subplots(figsize=(10, 8))
bplot = ax.boxplot(
    prices, labels=brand.index, patch_artist=True, showmeans=True, boxprops=dict(
        facecolor='hotpink'), medianprops=dict(
            color='k'), meanprops=dict(
                marker='*', markeredgecolor='k', markerfacecolor='k', markersize=8))

ax.set_title('Зависимость цены авто от марки', fontsize=14)
ax.set_xlabel("Марка авто", fontsize=14)
ax.set_ylabel('Цена, млн руб.', fontsize=14)
ax.yaxis.set_major_formatter(lambda x, p: format(round(x / 10**6, 2), ','))
ax.patch.set_facecolor('whitesmoke')
ax.yaxis.grid(True)

plt.xticks(rotation=45)
plt.savefig('Зависимость цены авто от марки.png')


# #### Зависимость цены авто от года выпуска, зависимость цены авто от количества владельцев


fig, ax = plt.subplots(1, 2, figsize=(24, 10))

prices = []
owners = owners.sort_index()
for b in owners.index:
    prices.append(df[df['num_of_owners'] == b]['price'])
bplot = ax[0].boxplot(
    prices, labels=owners.index, patch_artist=True, showmeans=True, boxprops=dict(
        facecolor='hotpink'), medianprops=dict(
            color='k'), meanprops=dict(
                marker='*', markeredgecolor='k', markerfacecolor='k', markersize=8))
ax[0].set_title('Зависимость цены авто от количества владельцев', fontsize=14)
ax[0].set_xlabel('Количество владельцев', fontsize=14)
ax[0].set_ylabel('Цена, млн руб.', fontsize=14)
ax[0].yaxis.set_major_formatter(lambda x, p: format(round(x / 10**6, 2), ','))
ax[0].patch.set_facecolor('whitesmoke')
ax[0].yaxis.grid(True)


prices = []
prices.append(list(df[df['year'] < 1980]['price']))
prices.append(list(df[(df['year'] < 1990) & (df['year'] >= 1980)]['price']))
prices.append(list(df[(df['year'] < 2000) & (df['year'] >= 1990)]['price']))
prices.append(list(df[(df['year'] < 2010) & (df['year'] >= 2000)]['price']))
prices.append(list(df[df['year'] >= 2010]['price']))

labels = ['до 1980', '1980-1989', '1990-1999', '2000-2009', '2010-2020']

bplot = ax[1].boxplot(
    prices, labels=labels, patch_artist=True, showmeans=True, boxprops=dict(
        facecolor='hotpink'), medianprops=dict(
            color='k'), meanprops=dict(
                marker='*', markeredgecolor='k', markerfacecolor='k', markersize=8))
ax[1].set_title("Зависимость цены авто от года выпуска", fontsize=14)
ax[1].set_xlabel("Год выпуска авто", fontsize=14)
ax[1].set_ylabel('Цена, млн руб.', fontsize=14)
ax[1].yaxis.set_major_formatter(lambda x, p: format(round(x / 10**6, 2), ','))
ax[1].patch.set_facecolor('whitesmoke')
ax[1].yaxis.grid(True)

plt.xticks(fontsize=12)
plt.subplots_adjust(wspace=0.1)
plt.savefig('Зависимость цены авто от количества владельцев, года выпуска.png')

# ### Корреляционная матрица для количественных переменных


cor = df.drop(['num_of_owners', 'year'], axis=1).corr('kendall')
col_names = ['Мощность', 'Пробег', 'Цена']
f = plt.figure(figsize=(8, 6))
plt.matshow(cor, fignum=f.number, cmap='RdGy_r')
plt.xticks(range(3), col_names, fontsize=10)
plt.yticks(range(3), col_names, fontsize=10)
cb = plt.colorbar()
cb.ax.tick_params(labelsize=10)
plt.title('Корреляционная матрица', fontsize=16)
plt.savefig('Корреляционная матрица для количественных переменных.png')
# plt.show()
cor.style.background_gradient(cmap='RdGy_r')

# ### Анализ наличия корреляции между независимыми переменными


lst = ['num_of_owners', 'year']  # качественные переменные
for i, elem_1 in enumerate(lst):
    for j, elem_2 in enumerate(lst):
        if i < j:
            # Таблица кросс-табуляции
            contigency = pd.crosstab(df[elem_1], df[elem_2], normalize='index')
            c, p, dof, expected = stats.chi2_contingency(
                contigency)  # Хи-квадрат тест
            print(f'{contigency}\np = {p}')

# chi2: The test statistic
# p: The p-value of the test
# dof: Degrees of freedom
# expected: The expected frequencies, based on the marginal sums of the table
# Большое p говорит о независимости